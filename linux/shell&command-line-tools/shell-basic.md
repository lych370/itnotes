[TOC]

# 简介

## 概念

Shell 是一个用 C 语言编写的程序，Shell 既是一种命令语言，又是一种程序设计语言。

> Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。
>
> Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。

- shell分类
   - Bourne：常见的是sh(Bourne Shell)和bash(Bourne Again Shell)，还有fish、zsh等等
   - C：cshell、tcsh（BSD的Unix)

  以下以bash为默认shell。

- shell查看

  ```shell
  echo $SHELL    #查看当前使用的shell
  cat /etc/shells    #查看当前系统支持的shell
  ```

- 扩展名sh：脚本文件**可以不使用扩展名** （但是使用扩展名sh，shell可以为代码提供颜色高亮）。

- 解释器：在脚本文件开始时使用shebang指定解释器，例如`#!/bin/sh`指定sh作为解释器。

  shebang，即sharp--`#`和ban--`!`的联合缩写。

- 为脚本添加执行权限：`chmod +x file.sh`。

- 执行脚本：

  - 脚本有可执行权限：`./file.sh``
  - 脚本无可执行权限：``bash file.sh`

- 命令别名alias

  示例：`alias ll='ls -al --color=auto'`  使用ll别名替代`ls -al --color=auto`这条命令，仅临时生效。

  可以在配置文件如`~/.bashr`中使用alias设置别名，使得该别名在当前用户下一直生效。

  添加别名后，使用`source ~/.bashrc`可使其立即生效。

- 命令优先级顺序：绝对/相对路径执行命令 > 别名 > bash内部命令 > $PATH环境变量定义的目录查找顺序的第一个命令 。

# 基础

## 基本特殊符号

- `#`：注释符号。

- `\`：反斜杠，转义符，将后一个特殊字符转为普通字符。

- 命令替换：在命令行中使用命令的输出来替换特定的命令。

  - ``：反引号，反引号内部的内容是系统命令，会最先执行。
  - `$()`：和反引号作用一样，只是反引号中对`\`进行了转义，而`$()`中没有。

- `()`：子命令组，**另开一个子shell**顺序执行，其中的变量不能够被外面部分使用。

- 路径

  - `/` ：斜杠，路径分隔符。
  - 路径简写
    - `~`： 当前用户的家目录
    - `-`：当前用户的上次工作目录
    - `..`：上一级目录
    - `.`：当前目录

- 引号

  - 单引号`' '`：引号内特殊字符**均无**特殊意义。
  - 双引号`" "`： 引号中除了` $ \ ""  （反引号、美元符号、反斜杠和双引号）外的特殊字符无特殊意义。

  注意：特殊字符\无特殊意义进指的\本身，不包括\与其他字符组合的控制符（如\n）。

- `&`：将命令放入后台执行。

- `:`：空命令。

上述特殊字符与其他字符组合成的特殊意义（如\加上一些字符成为特殊意义的[控制符](#控制符) ），以及其余特殊符号，归入后文各相关章节叙述。

## 多命令执行符号

### 逻辑符

- `; `  分号-- `a;b`   各命令间没有逻辑关系影响
- `&& `   逻辑与--`a&&b`    前面的命令正确执行，才能执行后面的命令
- `||`    逻辑或--`a||b`    前面的命令不能正确执行，就执行后面的命令

### 管道符

管道符pipeline  `|`

 `a|b`    管道符前面命令a的**正确输出**，作为管道符后面命令b的操作对象。

## 通配符

- `?`    匹配1个字符

- `*`    匹配任意个数字符

  特别的：

  ```shell
  x=*
  echo $x  #打印出当前目录下所有文件（夹）名 ，与echo *输出一致
  ```

- `[]`    匹配括号内任意一个字符（如`[ab]`匹配a或b或c）
  - `[-]`   匹配在编码顺序内的所有字符（如`[a-z]`匹配a到z的字母）
  - `[!]`    匹配**除了**`!`后面字符的其他字符（如`[!abc]`匹配除了abc的字符）

通配符与正则表达式见后文[正则表达式](#正则表达式) 。

## 控制符

[echo输出](#echo输出)命令中使用`-e`启用控制符

注意：退格键\b并不会在内容中删除\b前面一个字符，它**只是让光标**向前**移动**一格而已，回车键\r同理。

|   控制符   | 意义                                    |
| :--------: | :-------------------------------------- |
| \a 或 \007 | 警告声/响铃（alert bell）               |
|  \b或\010  | 退格（backspace）                       |
|  \E或\033  | 退出/取消（escpae）                     |
|  \f或\014  | 换页符（formfeed）                      |
|  \n或\012  | 换行符（new line）                      |
|  \r或\012  | 回车（return）                          |
|  \t或\011  | 表格跳位/制表符（tab）                  |
|     \v     | 垂直表格跳位/垂直制表符（vertical tab） |
|     \c     | 取消行末换行符 （cancel）               |
|   \0nnn    | 八进制数(nnn表示八进制数)               |
|    \xhh    | 十六进制数(hh表示十六进制数)            |
| \e[或\033[ | 字符转义为ANSI escape code              |

### ANSI escape code

`\e[`或`\033`是CSI，全称为“控制序列引导器”（Control Sequence Introducer/Initiator），能将字符转义成[ANSI escape code](https://en.wikipedia.org/wiki/ANSI_escape_code)

#### 显示样式和颜色

写法：在样式或颜色之后要使用m，如`1m`，如果使用颜色和样式，二者以`;`分隔，只在第二个数字后写上m即可，例如：`echo -e '\e[1;35m文字文字\e[0m'` 。

这些样式和颜色值是ANSI escape code中的[SGR](https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_codes) ，某些SGR码支持并不广泛，以下列出常见SGR code。

- 样式：
|  样式  |  加粗  |  弱化  |  斜体  | 下划线  |  闪烁  |  反色  |  隐藏  | 删除线  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  开启  |  1   |  2   |  3   |  4   |  5   |  7   |  8   |  9   |
|  关闭  |  21  |  22  |  23  |  24  |  25  |  27  |  28  |  29  |
**0恢复默认**样式。2弱化是指显示的颜色和粗细强度等减弱，22关闭弱化即使用普通效果（normal）。21具有关闭粗体或者设置双下划线的效果，不过几乎不被支持。

此外：6/26（快速闪烁，每分钟闪烁150+次）较少被支持；10用于设置首选字体，11-19设置其他代替字体，20设置哥特体。

- 颜色
|  颜色  |  黑   |  红   |  绿   |  黄   |  蓝   |  洋红  |  青   |  白   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 前景色  |  30  |  31  |  32  |  33  |  34  |  35  |  36  |  37  |
| 背景色  |  40  |  41  |  42  |  43  |  44  |  45  |  46  |  47  |

此外：38默认的前景颜色上设置下划线    39默认的前景颜色上关闭下划线    49默认背景色

#### 光标位置和键盘控制

参看ANSI escape code中中[CSI code](https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_codes)

- 光标位置

| 字符内容      | 光标位置说明         |
| :-------- | :------------- |
| \033[nA   | 上移n行           |
| \033[nB   | 下移n行           |
| \033[nC   | 右移n行           |
| \033[nD   | 左移n行           |
| \033[y;xH | 设置光标位置（第y行第x列） |
| \033[K    | 清除从光标到行尾的内容    |
| \033[s    | 保存光标位置         |
| \033[u    | 恢复光标位置         |
| \033[?25l | 隐藏光标           |
| \033[?25h | 显示光标           |
| \033[2J   | 清除屏幕           |

- 键盘控制
  - \033[0q         　关闭所有的键盘指示灯 
  - \033[1q         　设置“滚动锁定”指示灯 (Scroll Lock) 
  - \033[2q         　设置“数值锁定”指示灯 (Num Lock) 
  - \033[3q         　设置“大写锁定”指示灯 (Caps Lock) 


## 重定向

在 shell的命令执行的过程中，主要有三种输出入的状况，分别是：

1. 标准输入-键盘；代码为 0 ；或称为 stdin ；使用的方式为 `<`
2. 标准输出-显示器：代码为 1 ；或称为 stdout；使用的方式为 `1>`
3. 错误输出-显示器：代码为 2 ；或称为 stderr；使用的方式为 `2>`

| 说明                           | 命令                      |
| :--------------------------- | :---------------------- |
| 将输出重定向到 file                 | command > file          |
| 将输入重定向到 file                 | command < file          |
| 将输出以追加的方式重定向到 file           | command >> file         |
| 将文件描述符为 n 的文件重定向到 file       | n > file                |
| 将文件描述符为 n 的文件以追加的方式重定向到 file | n >> file               |
| 将输出文件 m 和 n 合并               | n >& m                  |
| 将输入文件 m 和 n 合并               | n <& m                  |
| 将开始标记和结束标记之间的内容作为输入          | << tag  [some info] tag |

如果希望执行某个命令，但又不希望在屏幕上显示输出结果:

- `command > /dev/null`   - /dev/null是一个空文件
- `command > /dev/zero`   -/dev/zero是一个无显示的无限输入文件

错误重定向相关

- `2>`      将一个标准错误输出重定向到一个文件或设备 **覆盖**（取代）原来的文件
- `2>>`    将一个标准错误输出重定向到一个文件或设备 **追加**到原来的文件
- `2>&1`    将一个**标准错误输出重定向到标准输出**
- `|&`     将一个标准错误 管道 输送 到另一个命令作为输入
- `&>>`    以**追加的方式把正确输出和错误输出都保存**到同一个文件中
- `&>`以**覆盖的方式把正确输出和错误输出都保存**到同一个文件中

## 输出输入命令

### echo输出

选项：

-  -e   启用[控制符](#控制符)转换
-  -E  关闭[控制符](#控制符)转换
-  -n  取消行末换行符（同[控制符](#控制符)中`\c` ）

输出的内容最好加上引号，否则在某些情况下会出问题（如使用空格、控制符号等的时候）。
```shell
echo a  #输出test
echo a\nb    #输出anb
echo -e "a\nb"    #输出a (换行) b
```

### printf输出

printf 命令模仿 C 程序库（library）里的 printf() 程序，使用printf的脚本比使用echo移植性好。

**默认printf不会像 echo 在输出内容尾部自动添加换行符**，需要手动添加 `\n`。

```shell
$ printf "Hello, Shell\n"
Hello, Shell
```

printf可是使用格式化字符串：`printf format-string [arguments...]`

格式化

参数：

- format-string： 为格式控制字符串
- arguments：为参数列表。

例如脚本内容：

```shell
#!/bin/sh
printf "%-10s %-8s %-4s\n" 姓名 性别 身高
printf "%-10s %-8s %-4.2f\n" 人甲 男 177.7 
printf "%-10s %-8s %-4.2f\n" 人乙 女 168.8 
```

将输出：

```shell
姓名     性别   身高
人甲     男      177.7
人乙     女      168.8
```

### read输入

选项：

- -p   提示信息
- -t    等待时间（单位：秒）
- -d   持续读取直到读入定界符（delimiter）为止
- -r    不允许反斜杠转义任何字符
- -n   指定接收输入的字符数
- -s    不显示输入的数据，用于机密信息的输入（如密码）

```shell
read -p "please input username:"
read -s -p "please input password:"
read -p "请输入名字：" name  #将用户的输入内容赋值给name变量
#使用-d -r 将多行内容存到一个变量中
read -d -r '' msg << TIP
You should reboot system after installation.\n
Good Luck!\n
TIP
echo $msg    #将会输出那两行提示内容 TIP是界定符 两个TIP间的内容被存到msg变量中
```

# 变量

## 变量分类

- 按数据类型划分
  - 字符串
  - 整型数字
  - 浮点型数字
  - 日期
- 以整个Linux操作系统为准，可如下分类
  - **用户自定义**变量
  - [环境变量](#环境变量)：保存和系统环境相关的数据；对系统生效的环境变量名和变量作用是固定的。`env`可查询当前环境变量。
  - [预定义变量](#预定义变量)：shell中（如bash中）已经定义好的变量，变量名不能自定义，变量作用固定。
  - [位置参数变量](#位置参数变量)：向脚本中传递参数或数据，变量名不能自定义，变量作用固定。
- 按作用域划分
  - 局部变量
  - 全局变量

		Shell函数的变量**默认是全局变量**，可使用`local 变量名=值 `关键字定义局部变量，其作用域局限于函数内。

### 用户自定义变量

- 定义变量：`变量名=值`，如`var1=123`
  - **首个字符必须为字母**（a-z，A-Z）。
  - 中间不能有空格，可以使用下划线（_）。
  - **不能使用标点符号**。
  - 不能使用shell里的关键字（可用help命令查看保留关键字）。
  - 赋值符号`=`**两边不能有空格**
  - 包含空白字符的值要使用引号（参看[基本特殊符号](#基本特殊符号)中单双引号的区别）  示例`'a b c'`
- 删除变量：`unset 变量名 `


- 查询变量：`set 变量名`

- 调用变量：`$变量名`或`${变量名}`，如 `$var1`或者`${var1}` 

  无大括号是简写方法，需要**使用`{}`的情况**：

  - 如果变量后面跟一个**非小写字符串、数字或下划线**   `${var}_1`
  - [位置参数变量](#位置参数变量)中**第10个及以后的参数的写法**
  - 增加可读性或避免混淆  例如`${var}test`和`$vartest`

### 环境变量

主要的几个环境变量配置文件：

- /etc/profie
- /etc/profile.d/*
- ~/.bash_profile
- ~/.bashrc
- /etc/bashrc

配置文件修改后立即生效，使用source，示例

```shell
source ~/.bashrc
#或者
. ~/.bashrc
```

### 预定义变量

| 预定义变量 | 说明                                                       |
| ---------- | ---------------------------------------------------------- |
| $?         | 返回最后一次执行的命令的退出状态码（0执行正确，1执行错误） |
| $$         | 当前进程号（PID）                                          |
| $!         | 后台运行的最后一个进程的进程号（PID）                      |

### 位置参数变量

| 位置参数变量 | 说明                                                     |
| :----------- | :------------------------------------------------------- |
| ${n}         | 第n个参数，0代表命令行本身，第0至9个参数可省略括号如`$0` |
| $*           | **所有参数的集合**，把所有参数视为一个整体               |
| $@           | **所有参数的集合**，把所有参数区分对待                   |
| $#           | 所有参数的个数                                           |

`$*`和`$@`：

- `$*`和`$@`  --  不加双引号`" "`时，**二者均会丢弃传入参数的引号**：

  例如传入的参数`"a b" c `

  `"$*"`参数：视作`a`、`b`和`c`三个参数的集合`"$@"`参数：视作`"a b"`和`c`两个参数的集合

- `"$*"`和`"$@"`  --  添加双引号`" "`时，`$@`会保留传入参数的引号，`$*`仍会丢弃传入参数的双引号。

## declare声明变量类型

用于变量类型声明。如不声明，变量默认类型是字符串。
选项：

- `-`    给变量设定类型属性
- `+`    取消变量的类型属性
- -a    将变量声明为**数组**型
- -i     将变量声明为**整数**型
- -x    将变量声明为**环境变量**
- -r    将变量声明为**只读**类型
- -p    **显示**指定变量的被声明的**类型**
- -f     仅显示函数

## 变量测试

| 变量置换方式        | 变量y没有设置    | 变量y为空值     | 变量           |
| ------------- | ---------- | ---------- | ------------ |
| `x=${y-新值} `  | x=新值       | x为空        | `x=$y`       |
| `x=${y:-新值}`  | x=新值       | x=新值       | `x=$y`       |
| `x=${y+新值}`   | x为空        | x=新值       | x=新值         |
| `x=${y:+新值}`  | x为空        | x为空        | x=新值         |
| `x=${y=新值}`   | x=新值 y=新值  | x为空 y值不变   | `x=$y`  y值不变 |
| `x=${y:=新值}`  | x=新值 y=新值  | x=新值 y=新值  | `x=$y`  y值不变 |
| `x=${y?新值}`   | 新值（标准错误）输出 | x值为空       | `x=$y`       |
| `x=${y:?新值} ` | 新值（标准错误）输出 | 新值（标准错误）输出 | `x=$y`       |

# 数组

Bash Shell 只支持一维数组。

- 定义数组的方式
  - 直接列出所有元素：`数组名=(元素0 元素1 ... 元素n)`， 使用空格隔开各个元素。
  - 单独对某个元素赋值：`数组名[下标]=值`

  ```shell
  array1=(1 2 3 4 5)
  array2[1]=123
  array2[2]=567
  ```


- 读取数组信息
  - 某个数组元素：`${数组名[下标]}`
  - 数组所有元素：`${数组名[*]}`或`${数组名[@]}`
  - 数组长度：`${#数组名[*]}`或`${#数组名[@]}`  （比读取数组所有元素多一个`#` ）

  ```shell
  echo ${array1[0]}
  echo ${array2[*]}
  echo ${#array2[*]}
  ```

# 运算符

shell运算符包括：算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。

## 算术运算符

同多数是编程语言一致，不再列出。**shell变量默认类型为字符串**，可使用以下方法进行数值运算（主要是整数运算）。

- `(())`表达式

  ```shell
  a=1
  b=2
  c=$(($a+$b))  #c为3
  ((b+=2))  #b为4
  ```


- `$[]`表达式

  ```shell
  var=1
  var=$[$var+1]
  echo $var
  ```


- `declare`命令

  ```shell
  a=1
  declare -i c = $a + 1  #声明为整数
  echo c    #c为2
  ```


- `expr`命令

  - 只能进行整数运算
  - expr命令后把的算式中，**操作符和操作数之间必须有空格**

  ```shell
  expr 17 \* 6    #102  整数运算  #要使用\对*进行转
  expr $var1 + $var2  #注意加号两侧空格
  ```


  此外`expr`还能操作字符串：

  ```shell
  expr length "string"    #6  字符串长度
  expr substr "this-string" 3 5    #is  在[3,5)区间查找字符串
  expr index "string" s   #1  s第一次出现的位置
  ```

- `let`命令

  ```shell
  let a=1+1    #a为2
  let a++	   #a为3
  let a-=2    #a为1
  echo $a   # 1
  ```

- bc命令

## 关系运算符

**关系运算符只支持数字**，不支持字符串，除非字符串的值是数字。(字符串参看[字符串运算符](#字符串运算符))

`数字1 选项 数字2`根据各选项，将第一个数和第二个数对比，判断对比情况，返回true/false。

|  选项  | 说明                            |
| :--: | :---------------------------- |
| -eq  | 是否相等（equal）                   |
| -ne  | 是否不等（not equal）               |
| -gt  | 是否更大（greater than）            |
| -lt  | 是否更小（less than）               |
| -ge  | 是否大于等于（greater than or equal） |
| -le  | 是否小于等于（less than or equal）    |

## 字符串运算符

空和非空：`选项 字符串（或变量）` ；等和不等：`字符串1 选项 字符串2` ，根据各选项判断字符串情况，返回true或false。

|  选项  | 说明         |
| :--: | ---------- |
|  -z  | 字符串长度是否为0  |
|  -n  | 字符串长度是否不为0 |
| ==或= | 是否相等       |
|  !=  | 是否不相等      |

注意：

- 使用`-n`在`[]`结构中测试必须要用`" "`把变量引起来或使用`[[ ]]`。
- 判断是否相等时，在`=` 、`==`或`!=`的两侧一定要有空格（`=`两侧不加空格是赋值）。
- 最好不要使用`=`或`!=`对数值进行判断（会被当作字符串进行对比）。

提示：判断字符串是否为空最可靠的方法：`"x${value}" == "x"`

## 布尔运算符

非运算：`! 表达式`；与/或运算：`表达式1 选项 表达式2` ，根据各表达式情况判断，返回true或false。

- !    非运算
- -o    或运算
- -a    与运算

## 逻辑运算符

`表达式1 选项 表达式2`

- &&    逻辑与
- ||    逻辑或

## 文件测试运算符

### 文件类型

` 选项 文件名`根据各选项，判断文件的某种情况，返回true或false。

|  选项  | 说明                       |
| :--: | ------------------------ |
|  -b  | 判断文件是否存在，且是否为**块设备**文件   |
|  -c  | 判断文件是否存在，且是否为**字符设备**文件  |
|  -d  | 判断文件是否存在，且是否为**目录**文件    |
|  -e  | 判断文件是否存在                 |
|  -f  | 判断文件是否存在，且是否为**普通**文件    |
|  -L  | 判断文件是否存在，且是否为块**符号链接**文件 |
|  -p  | 判断文件是否存在，且是否为**管道**文件    |
|  -s  | 判断文件是否存在，且是否为非空          |
|  -S  | 判断文件是否存在，且是否为**套接字**文件   |

### 文件权限

`选项 文件名`根据各选项，判断某项权限的情况，返回true或false。

|  选项  | 说明                  |
| :--: | ------------------- |
|  -r  | 判断文件是否存在，且是否有读权限    |
|  -w  | 判断文件是否存在，且是否有写权限    |
|  -x  | 判断文件是否存在，且是否有执行权限   |
|  -u  | 判断文件是否存在，且是否有SUID权限 |
|  -g  | 判断文件是否存在，且是否有SGID权限 |
|  -k  | 判断文件是否存在，且是否有SBit权限 |

###　文件对比

`文件名1 选项 文件名2`根据各选项，将第一个文件和第二个文件对比，判断对比情况，返回true/false。

|  选项  | 说明                       |
| :--: | ------------------------ |
| -nt  | 判断文件修改时间是否更新             |
| -ot  | 判断文件修改时间是否更晚             |
| -ef  | 判断文件的Inode是否一致（一致则为同一文件） |

# 正则表达式

这里不详述正则表达式相关内容，具体参看正则表达式和相关工具文档。

**正则表达式与[通配符](#通配符)**：

正则表达式是**包含匹配**，用于**文件内容**匹配；通配符是**完全匹配**，多用于**文件名**匹配。

- 支持正则：grep 、cut、sort、awk、sed、uniq
- 只支持通配符不支持正则：find、cp、ls、rm

应注意shell中字符在正则表达式中的不同意义或用法：

- `$`  shell中用作变量引用的时置于变量名前的标志符号；正则中表示字符串末尾。
- `*`  通配符中可单独使用，代表任意个数字符；**正则中不能单独使用**，表示重复前面的内容任意次。
- `?`  通配符中可单独使用，代表1字符；**正则中不能单独使用**，表示重复前面的内容0次或1次。

# 测试表达式

各类参见运算符号（除算术运算）中各个运算符使用说明：[数值关系判断](#关系运算符)、[字符串运算符](#字符串判断)、[布尔运算符](#布尔值判断)、[逻辑运算符](#逻辑判断)和[文件测试运算符](#文件判断)。

测试表达式会返回状态码（参看[预定义变量](#预定义变量)中的`$?`），0表示执行正确（true），1执行错误（false）。

- `test`关键字：`test 表达式`
- 单中括号`[ ]`和双中括号`[[ ]]`：`[ 表达式 ]` 和`[[ 表达式 ]]`
  - **`[ ]`在参数只是一个变量时，会把变量当字符串** 。（类似单双引号）
  - **`[[ ]]`可以使用`&&`  `||`  `<`  `>` 操作符**而`[ ]`中不可以。
  - 这两个命令作用同`test`（相当于是`test`的别名）。
  - 表达式与括号`[]`或`[[ ]]`之间**必须有空格** ，因为`[`和`[[`是linux内部命令（不过，算数运算中的`$[]`不需要有空格）。


# 流程控制

- **在关键字（如if）和中括号`[ ]`或`[[ ]]`之间必须要有空格** 。
- 如果两条命令写在一行，每条命令后面需要添加`;`进行间隔。

## 分支

### 单分支

```shell
if [ expression ]
then
	#some codes
fi
#或者这样写
if [ expression ]; then
	#some codes
fi
```
### 双分支

```shell
if [ expression ]
then
	#some codes
else
	#some codes
fi
```
### 多分支
#### 多分支if
```shell
if [ expression ]
then
	#some codes
elif [ expression ]
then
	#some codes
else
	#some codes
fi
```
#### 多分支case
```shell
case var in
value1)
	#some codes
	;;
value2 | value3)   #可以使用逻辑符号
	#some codes
	;;
*)	#最后一个默认分支的值使用*
	#some codes
;;
esac
```
## 循环

- 跳出循环：`break`
- 结束当前迭代，进入下一次迭代：`contiune`
- 循环的输入输出重定向：在`done`后面添加命令，例如`done > output.txt` `done | wc -l`
- 后台执行重定向：在`done`命令后面添加`&`
- `getops`根据用户指定的每个选项执行所需要的操作，没有找到要求的参数，它会将问号保存到变量中并向标准错误中输出错误信息。

### for循环

```shell
for var in value1 value2 value3
#for var in ${arr[*]}  #数组
#for var in $(cat testfile)  #从文件中获取变量列表

#也可以这样写，注意：shell中不能写i+=1
for ((i=1;i<=100;i=i+1))
do
	#some codes
done
```

### while循环和util循环

- while循环：expression中条件为真时进行循环：

```shell
while(expression)
do
	#some codes
done
```

- until循环：**与while相反**，expression中条件为**假**时进行循环：

```shell
util expression
do
	#some codes
done
```
# 函数

- 声明

  ```shell
  function fn () {
      # action
      return <int>;
  }
  ```

  - `function`关键字和函数名后面的小括号可以省略。
  - 函数名中的小括号中不能写参数，使用参数参看下面的[函数参数](#函数参数)。
  - 参数返回，可以显示加`return` 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）

- 调用

  ```shell
  fn [参数] [参数] [...]
  ```

  函数调用的参数写在函数名后即可（空格隔开）。

## 函数参数

通过 `$n` 的形式来获取参数的值，例如`$1`和`$2`， 当n>=10，即从第10可参数起，必须以`${n}`的形式书写，如`${10}`和`{11}` 。

处理参数的特殊字符：

- `$#`    传递到脚本的参数个数
- `$*`    以一个单字符串显示所有向脚本传递的参数
- `$@`  与`$*`相同，但是使用时加引号，并在引号中返回每个参数。
  - `$-`  显示Shell使用的当前选项，与set命令功能相同。
  - `$?`  显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
  - `$$`   脚本运行的当前进程ID号
  - `$!`  后台运行的最后一个进程的ID号

# 引用外部脚本

两种书写格式：

- `. filename `      注意点号`.`和文件名中间有一空格
- `source filename`    （如` source .test.sh` ）

**注：**被包含的文件可以没有可执行权限。

# 执行外部脚本

- **fork**——直接在脚本里面执行脚本

  将新开一个shell来执行，子 Shell 可以从父 Shell 继承环境变量，但是子 Shell 中的环境变量不会带回给父 Shell。

  - 如果脚本有执行权限：`path/to/file.sh`
  - 如果没有执行权限：`sh path/to/file.sh`——建议

- **exec**： `exec path/to/file.sh`

  不需要新开一个子 Shell 来执行被调用的脚本，被调用的脚本与父脚本在同一个 Shell 内执行。

- **source**: `source path/to/file.sh`

  同一个 Shell 中执行，在被调用的脚本中声明的变量和环境变量, 都可以在主脚本中进行获取和使用，相当于合并两个脚本在执行。

# 向脚本传递参数

通过[预定义变量]($预定义变量)和[位置参数变量](#位置参数变量)调用传入的参数。示例如下：

- 脚本`see`内容

  ```shell
  !/bin/sh
  cat $1
  ```

- 文件test内容

  ```shell
  line1
  line2
  ```

执行`./see test`后，test文件作为参数传给`see`脚本，相当于执行了`cat test`。

# shift向左移动位置参数

shift执行后，位置参数向左移动，也就是最后一个参数会被丢弃。

示例脚本`run`：

```shell
#!/bin/bash
while [ $# != 0 ]
do
echo "prama is $1,prama size is $#"
shift
done
```

运行`run a b c`，返回内容为：

> prama is a,prama size is 3
> prama is b,prama size is 2
> prama is c,prama size is 1



# exit

`exit n` n为返回的状态码，如果不指定，则根据情况返回0或1

